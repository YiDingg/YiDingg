# C语言笔记 (3)：数据类型

## 基本数据类型大小
在不同位数的系统中，基本数据类型大小不尽相同，最典型的例子即为指针的大小，因为它与寻址空间大小有关。
下表列出了常见系统中各基本数据类型的大小（单位Byte）：

<div class='center'>

|数据类型|16位|32位|64位|
|:-:|:-:|:-:|:-:|
|*void|2|4|8|
|char|1|1|1|
|short (int)|2|2|2|
|int|2|4|4|
|long (int)|4|4|8|
|long long (int)|8|8|8|
|float|4|4|4|
|double|8|8|8|
|long double|16|16|16|
</div>

## 类型总结

具体的详细内容我们不再赘述，下面简要提几个部分。

### char

`char`类型使用一个字节（8位）存储，在不同计算机的默认范围是不一样的，一些系统默认为-128到127，另一些系统默认为0到255。这两种范围正好都能覆盖0到127的 ASCII 字符范围。只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。

单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义。例如`char t = '\'';`。

下面列出了部分转义字符：

- `\n`：换行符。
- `\r`：回车符，光标移到同一行的开头。
- `\t`：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
- `\v`：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
- `\0`：null 字符，代表没有内容，也称停止符。注意，这个值不等于数字0。
- `\{num}`：字符的八进制写法，`{num}`为八进制值。
- `\x{num}`：字符的十六进制写法，`{num}`为十六进制值。

例如，下面示例的四种写法等价：

```c
char x = 'B';
char x = 66;
char x = '\102'; // 八进制
char x = '\x42'; // 十六进制
```

### int

`unsigned`和`signed`略过，提一下`short`和`long`，它们可以修饰`int`构成其子类型，如下：

```c
unsigned short int a; unsigned short a;
unsigned long int b; unsigned long b;
unsigned long long int c; unsigned long long c;
```

`int`可以省略，因此同一行的两个语句是等价的。


### 数值范围

有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件`limits.h`提供了相应的常量，比如`SCHAR_MIN`代表 signed char 类型的最小值`-128`，`SCHAR_MAX`代表 signed char 类型的最大值`127`。

为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。

- `signed char`: SCHAR_MIN, SCHAR_MAX
- `short`: SHRT_MIN, SHRT_MAX
- `int`: INT_MIN, INT_MAX
- `long`: LONG_MIN, LONG_MAX
- `long long`: LLONG_MIN, LLONG_MAX
- `unsigned char`: UCHAR_MAX
- `unsigned short`: USHRT_MAX
- `unsigned int`: UINT_MAX
- `unsigned long`: ULONG_MAX
- `unsigned long long`: ULLONG_MAX

C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。

二进制用`0b`或`0B`作前缀(不是所有编译器)，八进制用`0`作前缀，十六进制用`0x`或`0X`作前缀。例如下面的语句等价：

```c
int x = 12;
int x = 0b1100; // 二进制
int x = 014; // 八进制
int y = 0xC; // 十六进制
```

注意，不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。所有整数都是二进制形式存储，跟书写方式无关。不同进制可以混合使用，比如`10 + 015 + 0x20`是一个合法的表达式。


### float

浮点数都是用 $c\times a^b$ 的形式存储的，$c$ 称为小数部分，$a$ 称为底数(常为10)，$b$ 称为指数。

`float`类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号，至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）`-37`到`37`，即数值范围为 $10^{-37}$ 到 $10^{37}$。
有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。

- `double`：占用8个字节（64位），至少提供13位有效数字。
- `long double`：通常占用16个字节。

注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面`0.1 + 0.2`并不等于`0.3`，而是有一个很小的误差。例如语句 `0.1 + 0.2 == 0.3`返回0。

C 语言允许使用科学计数法表示浮点数，使用字母`e`来分隔小数部分和指数部分。另外，科学计数法的小数部分如果是 $0.x$ 或 $x.0$ 的形式，那么0可以省略，如下：

```c
/* 123.456 x 10^3 */
double x = 123.456e+3; 
double x = 123.456e3;

0.3E6 /* 等同于 */ .3E6
3.0E6 /* 等同于 */ 3.E6
```

###  boolean

曾经C语言并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。C99 标准添加了类型`_Bool`，表示布尔值。事实上这个类型用了`int`，还是使用0表示伪，1表示真。另外，头文件`stdbool.h`定义了另一个类型别名`bool`，并且定义了`true`代表1、`false`代表0。只要`#include`这个头文件，就可以使用这几个关键字。

下面是一个示例：

``` c
_Bool isNormal;
isNormal = 1;
if (isNormal){printf("Everything is OK.\n");}

/* <stdbool.h> 是在当前目录下寻找，"" 是在根目录下寻找*/
#include "stdbool.h" 
bool flag = false;
```

### 字面量类型

字面量（literal）指的是代码里面直接出现的值。例如，在`int x = 123;`中，`x`是变量，`123`就是字面量。

编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样。

一般情况下，十进制整数字面量（比如`123`）会被编译器指定为`int`类型。小数（比如`3.14`）会被指定为`double`类型。

有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为`int`类型，但是程序员希望将其指定为`long`类型，这时可以为该字面量加上后缀`l`或`L`，`int x = 123L;`，编译器就知道要把这个字面量的类型指定为`long` (建议使用`L`，避免与1混淆)。

常用literal后缀如下：

- `f`和`F`：`float`类型。
- `l`和`L`：对于整数是`long int`类型，对于小数是`long double`类型。
- `ll`和`LL`：Long Long 类型，比如`3LL`。
- `u`和`U`：表示`unsigned int`，比如`15U`、`0377U`。

### 溢出

一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位(向下溢出会得到全1)，这样往往会得到意想不到的结果。所以，应该避免溢出。

一种典型的错误是：

``` c
unsigned int i = 5;
unsigned int j = 7;

if (i - j < 0) // 错误
  printf("negative\n");
else
  printf("positive\n");
```

结果会输出`positive`。原因是变量`i`和`j`都是 unsigned int 类型，`i - j`的结果也是这个类型，最小值为`0`，不可能得到小于`0`的结果。正确的写法是写成下面这样。

### sizeof

`sizeof`是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。

```c
// 参数为数据类型
int x = sizeof(int);

// 参数为变量
int i;
sizeof(i);

// 参数为数值
sizeof(3.14);
```

上面的第一个示例，返回得到`int`类型占用的字节数量（通常是`4`或`8`）。第二个示例返回整数变量占用字节数量，结果与前一个示例完全一样。第三个示例返回浮点数`3.14`占用的字节数量，由于浮点数的字面量一律存储为 double 类型，所以会返回`8`，因为 double 类型占用的8个字节。

`sizeof`运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定，`sizeof`到底返回什么类型。不同的系统中，返回值的类型有可能是`unsigned int`，也有可能是`unsigned long`，甚至是`unsigned long long`，对应的`printf()`占位符分别是`%u`、`%lu`和`%llu`。这样不利于程序的可移植性。

C 语言提供了一个解决方法，创造了一个类型别名`size_t`，用来统一表示`sizeof`的返回值类型。该别名定义在`stddef.h`头文件（引入`stdio.h`时会自动引入）里面，对应当前系统的`sizeof`的返回值类型，可能是`unsigned int`，也可能是`unsigned long`。

C 语言还提供了一个常量`SIZE_MAX`，表示`size_t`可以表示的最大整数。所以，`size_t`能够表示的整数范围为`[0, SIZE_MAX]`。

`printf()`有专门的占位符`%zd`或`%zu`，用来处理`size_t`类型的值。

```c
printf("%zd\n", sizeof(int));
```

上面代码中，不管`sizeof`返回值的类型是什么，`%zd`占位符（或`%zu`）都可以正确输出。


### 混合类型运算

不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算。转换规则如下：

1. 整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。
2. 不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如`float`转为`double`，`double`转为`long double`。
3. 不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如`short`转为`int`，`int`转为`long`等，<strong style='color:red'>有时还会将带符号的类型`signed`转为无符号`unsigned`。</strong>

下面例子的执行结果，可能会出人意料。

```c
int a = -5;
if (a < sizeof(int)）
  do_something();
```

上面示例中，变量`a`是带符号整数，`sizeof(int)`是`size_t`类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以`a`会自动转成无符号整数`4294967291`（转换规则是`-5`加上无符号整数的最大值，再加1），导致比较失败，`do_something()`不会执行。

所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将`signed int`转为`unsigned int`，可能不会得到预期的结果。

### 可移植类型

C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。

程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件`stdint.h`创造了一些新的类型别名。

（1）精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。

- `int8_t`：8位有符号整数。
- `int16_t`：16位有符号整数。
- `int32_t`：32位有符号整数。
- `int64_t`：64位有符号整数。
- `uint8_t`：8位无符号整数。
- `uint16_t`：16位无符号整数。
- `uint32_t`：32位无符号整数。
- `uint64_t`：64位无符号整数。

上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果`int`类型为32位，`int32_t`就会指向`int`；如果`long`类型为32位，`int32_t`则会指向`long`。

下面是一个使用示例。

```c
#include <stdio.h>
#include <stdint.h>

int main(void) {
  int32_t x32 = 45933945;
  printf("x32 = %d\n", x32);
  return 0;
}
```

上面示例中，变量`x32`声明为`int32_t`类型，可以保证是32位的宽度。

（2）最小宽度类型（minimum width type），保证某个整数类型的最小长度。

- int_least8_t
- int_least16_t
- int_least32_t
- int_least64_t
- uint_least8_t
- uint_least16_t
- uint_least32_t
- uint_least64_t

上面这些类型，可以保证占据的字节不少于指定宽度。比如，`int_least8_t`表示可以容纳8位有符号整数的最小宽度的类型。

（3）最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型。

- int_fast8_t
- int_fast16_t
- int_fast32_t
- int_fast64_t
- uint_fast8_t
- uint_fast16_t
- uint_fast32_t
- uint_fast64_t

上面这些类型是保证字节宽度的同时，追求最快的运算速度，比如`int_fast8_t`表示对于8位有符号整数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32位计算机对于32位数据的运算速度，会快于16位数据。

（4）可以保存指针的整数类型。

- `intptr_t`：可以存储指针（内存地址）的有符号整数类型。
- `uintptr_t`：可以存储指针的无符号整数类型。

（5）最大宽度整数类型，用于存放最大的整数。

- `intmax_t`：可以存储任何有效的有符号整数的类型。
- `uintmax_t`：可以存放任何有效的无符号整数的类型。

上面的这两个类型的宽度比`long long`和`unsigned long`更大。